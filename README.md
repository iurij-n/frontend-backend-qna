# Этап 1: Теоретические вопросы (15-20 минут)

## 1. Frontend

### 1) Объясните разницу между виртуальным DOM и реальным DOM и почему React использует виртуальный DOM.

Реальный DOM — это фактическая структура документа в браузере, представленная в виде дерева объектов, с которой напрямую взаимодействует движок рендеринга. Виртуальный DOM — это легковесная копия реального DOM, которая хранится в памяти и используется React для оптимизации обновлений. Когда данные меняются, React сначала обновляет виртуальный DOM, сравнивает его с предыдущей версией (процесс diffing), а затем вносит только необходимые изменения в реальный DOM. Это быстрее, чем прямое манипулирование реальным DOM, так как операции с ним дорогостоящие из-за перерисовки и reflow. React использует виртуальный DOM для повышения производительности и упрощения управления состоянием интерфейса.

VueJS, тоже использует виртуальный DOM по схожим причинам.

### 2) В чем различие между `==` и `===` в JavaScript? Приведите примеры, когда каждый из них будет давать неожиданные результаты.

`==` (нестрогое сравнение) приводит операнды к общему типу перед сравнением.
`===` (строгое сравнение) сравнивает значения без приведения типов.

`==` может дать неожиданный результат, например:
```js
'5' == 5 // true, потому что строка '5' приводится к числу 5
```
`===` строже:
```js
'5' === 5 // false, так как строка и число - разные типы
```
`==` может быть полезен в редких случаях, например:
```js
if (value == null) // Проверяет одновременно null и undefined
```

### 3) Опишите, что такое “контекст” в JavaScript и как он может изменяться. Приведите примеры использования `bind`, `call` и `apply`.

Контекст (`this`) в JS — это объект, к которому относится выполняемая функция. Контекст определяется тем, как функция вызывается, и может изменяться в зависимости от вызова.

- **По умолчанию**: В глобальной области видимости `this` ссылается на `window` (в браузере) или `global` (в Node.js).
- **В методе объекта**: `this` ссылается на объект, в котором метод вызван.
- **В стрелочных функциях**: `this` берется из окружающего лексического контекста (не изменяется при вызове).
- **С помощью `bind`, `call`, `apply`**: Контекст можно явно задать.

Пример:
```js
const obj = { name: 'Alex' };
function say() { console.log(this.name); }
const boundSay = say.bind(obj);
boundSay(); // 'Alex'
```

### 4) Объясните, как работают `promises` и `async/await`, и приведите пример кода с обработкой ошибок.

`Promises` и `async/await` — это механизмы для работы с асинхронным кодом в JavaScript.

#### Пример `Promise` с обработкой ошибок:
```js
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = Math.random() > 0.5;
      success ? resolve("Data fetched!") : reject("Error: Failed to fetch data");
    }, 1000);
  });
}

fetchData()
  .then((data) => console.log(data))
  .catch((error) => console.error(error))
  .finally(() => console.log("Operation complete."));
```

#### `async/await` с обработкой ошибок:
```js
async function fetchData() {
  try {
    const response = await fetchData();
    console.log(response);
  } catch (error) {
    console.error(error);
  } finally {
    console.log("Operation complete.");
  }
}
fetchData();
```

## 2. Backend

### 1) Как вы обеспечиваете безопасность API от SQL-инъекций? Какие еще типы атак нужно учитывать?

- **Защита от SQL-инъекций**: Использование ORM (например, Django ORM), которое автоматически экранирует данные.
- **Другие атаки**:
  - **XSS (Cross-Site Scripting)**: Валидация и экранирование пользовательского ввода.
  - **CSRF (Cross-Site Request Forgery)**: Использование CSRF-токенов (в Django встроено).
  - **DoS (Denial of Service)**: Ограничение запросов (rate limiting) и валидация данных.

### 2) Объясните, что такое RESTful API и какие существуют методы HTTP-запросов. Как они соответствуют CRUD-операциям?

RESTful API — это архитектурный стиль для создания API, основанный на HTTP, где ресурсы доступны по URL, а операции с ними выполняются через стандартные методы HTTP.

- **GET** — получение данных (Read)
- **POST** — создание ресурса (Create)
- **PUT/PATCH** — обновление ресурса (Update)
- **DELETE** — удаление ресурса (Delete)

### 3) Чем отличаются реляционные и нереляционные базы данных? В каких случаях лучше использовать каждую из них?

- **Реляционные БД (PostgreSQL, MySQL)**: Хранят данные в таблицах с фиксированной схемой, обеспечивают целостность (ACID). **Применение**: финансы, CRM.
- **Нереляционные БД (MongoDB, Redis)**: Гибкая структура, удобны для хранения документов и больших объемов данных. **Применение**: соцсети, аналитика.

### 4) Как бы вы организовали логирование и мониторинг для серверного приложения?

- **Логирование**: Django logging, ELK-стек (Elasticsearch, Logstash, Kibana)
- **Мониторинг**: Prometheus (метрики), Grafana (визуализация)

## 3. Базы данных

### 1) Объясните разницу между индексацией и нормализацией данных. Приведите пример, когда избыточность данных может быть полезной.

- **Индексация**: Ускоряет поиск по столбцам.
- **Нормализация**: Устранение избыточности данных, разбиение таблиц.
- **Пример избыточности**: Хранение итоговой суммы заказа в `orders`, несмотря на возможность вычисления через `order_items`.

### 2) В чем различие между `JOIN` и `UNION` в SQL? Когда использовать каждый из них?

- **`JOIN`**: "Горизонтальное" объединение данных из связанных таблиц.
- **`UNION`**: "Вертикальное" объединение результатов нескольких `SELECT`-запросов.

Используйте `JOIN`, если нужно объединить данные из нескольких таблиц, и `UNION`, если нужно объединить результаты двух однотипных запросов.


# Этап 3: Задача на рефакторинг и код-ревью (30 минут)

## Читаемость:

- Использование `for` с индексами (`i`) устарело. Лучше использовать `for...of` или методы массива, такие как `forEach`.
- Логика внутри цикла слишком громоздкая, что затрудняет понимание.
- Много повторяющегося кода, например, `console.log` с похожими сообщениями.

## Производительность:

- Код не оптимизирован для больших массивов, так как каждый вызов `new Date()` выполняется внутри цикла.

## Поддержка:

- Логика обработки статусов задач смешана в одном блоке, что усложняет добавление новых статусов или изменение существующих.

## Улучшенный вариант:

```javascript
function processTasks(tasks) {
    const result = {
        completed: [],
        pending: [],
        overdue: [],
    };

    const currentDate = new Date();
    const logStatus = (task, status) => console.log(`Task ${task.name} is ${status}`);


    tasks.forEach(task => {
        const { status, dueDate, dateCompleted } = task;
        const isOverdue = dueDate && new Date(dueDate) < currentDate;

        switch (status) {
            case 'completed':
                if (!dateCompleted) task.dateCompleted = currentDate;
                result.completed.push(task);
                logStatus(task, 'completed');
                break;
            case 'pending':
                isOverdue ? result.overdue.push(task) : result.pending.push(task);
                logStatus(task, isOverdue ? 'overdue' : 'pending');
                break;
            case 'canceled':
                logStatus(task, 'canceled');
                break;
            default:
                logStatus(task, 'unknown');
        }
    });

    return result;
}
```

---

# Этап 4: Архитектурное мышление (30-45 минут)

## Задание

Опишите, как бы вы спроектировали архитектуру системы для "Списка задач", если бы она должна была поддерживать:
- Несколько тысяч пользователей одновременно.
- Возможность реального времени (например, обновление списка задач в реальном времени при изменении статуса).
- Безопасность данных (например, разделение задач по правам доступа).

## 1. Какие технологии и подходы они выбрали бы для frontend и backend?

### Backend:
- **Django REST Framework**: Для создания API, масштабируемости и надежности.
- **PostgreSQL**: Надежная и масштабируемая база данных.
- **Redis**: Для кэширования.
- **DjangoQ**: Для фоновых задач.

### Frontend:
- **Vue.js**: Легкий, гибкий и производительный фреймворк.
- **Vuex**: Для управления состоянием приложения.
- **Axios**: Для запросов к API.

- **Websockets**: Для реализации функциональности реального времени.

## 2. Как бы они реализовали масштабируемость и устойчивость системы?

- **Горизонтальное масштабирование** - использование нескольких серверов для backend и frontend.
- **Балансировка нагрузки** - распределение нагрузки между серверами с помощью Nginx.
- **Кэширование**: Использование Redis для кэширования часто используемых данных.
- **Контейнеризация**: Использование Docker и Kubernetes для управления контейнерами и оркестрации.
- **Использование асинхронных задач**: DjangoQ.
- **Мониторинг и логирование**: Использование инструментов для мониторинга производительности и отслеживания ошибок.

## 3. Как бы организовали защиту данных и обработку пользовательских ошибок?

- **Шифрование данных** - HTTPS для защиты данных при передаче.
- **Валидация данных** на backend и frontend.
- **Защита от SQL-инъекций и XSS-атак**.
- **Обработка ошибок** - API возвращает корректные коды ошибок (400, 401, 403, 500), Vue показывает уведомления пользователю.
- **Разделение прав доступа** - использование ролей и разрешений для ограничения доступа к данным.

## 4. Как бы они обеспечили тестируемость и легкость поддержки проекта?

- **Модульное тестирование**: Написание модульных тестов для backend и frontend.
- **Интеграционное тестирование**: Написание интеграционных тестов для проверки взаимодействия между компонентами.
- **Code review**: Регулярное проведение code review для обеспечения качества кода.
- **Документация**: Написание документации для API и frontend.
- **Использование CI/CD**: Автоматизация процессов сборки, тестирования и развертывания.
- **Разделение кода** на логические модули и компоненты.
