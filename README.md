# Этап 1: Теоретические вопросы (15-20 минут)

## 1. Frontend

### 1) Объясните разницу между виртуальным DOM и реальным DOM и почему React использует виртуальный DOM.

Реальный DOM — это фактическая структура документа в браузере, представленная в виде дерева объектов, с которой напрямую взаимодействует движок рендеринга. Виртуальный DOM — это легковесная копия реального DOM, которая хранится в памяти и используется React для оптимизации обновлений. Когда данные меняются, React сначала обновляет виртуальный DOM, сравнивает его с предыдущей версией (процесс diffing), а затем вносит только необходимые изменения в реальный DOM. Это быстрее, чем прямое манипулирование реальным DOM, так как операции с ним дорогостоящие из-за перерисовки и reflow. React использует виртуальный DOM для повышения производительности и упрощения управления состоянием интерфейса.

VueJS, тоже использует виртуальный DOM по схожим причинам.

### 2) В чем различие между `==` и `===` в JavaScript? Приведите примеры, когда каждый из них будет давать неожиданные результаты.

`==` (нестрогое сравнение) приводит операнды к общему типу перед сравнением.
`===` (строгое сравнение) сравнивает значения без приведения типов.

`==` может дать неожиданный результат, например:
```js
'5' == 5 // true, потому что строка '5' приводится к числу 5
```
`===` строже:
```js
'5' === 5 // false, так как строка и число - разные типы
```
`==` может быть полезен в редких случаях, например:
```js
if (value == null) // Проверяет одновременно null и undefined
```

### 3) Опишите, что такое “контекст” в JavaScript и как он может изменяться. Приведите примеры использования `bind`, `call` и `apply`.

Контекст (`this`) в JS — это объект, к которому относится выполняемая функция. Контекст определяется тем, как функция вызывается, и может изменяться в зависимости от вызова.

- **По умолчанию**: В глобальной области видимости `this` ссылается на `window` (в браузере) или `global` (в Node.js).
- **В методе объекта**: `this` ссылается на объект, в котором метод вызван.
- **В стрелочных функциях**: `this` берется из окружающего лексического контекста (не изменяется при вызове).
- **С помощью `bind`, `call`, `apply`**: Контекст можно явно задать.

Пример:
```js
const obj = { name: 'Alex' };
function say() { console.log(this.name); }
const boundSay = say.bind(obj);
boundSay(); // 'Alex'
```

### 4) Объясните, как работают `promises` и `async/await`, и приведите пример кода с обработкой ошибок.

`Promises` и `async/await` — это механизмы для работы с асинхронным кодом в JavaScript.

#### Пример `Promise` с обработкой ошибок:
```js
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = Math.random() > 0.5;
      success ? resolve("Data fetched!") : reject("Error: Failed to fetch data");
    }, 1000);
  });
}

fetchData()
  .then((data) => console.log(data))
  .catch((error) => console.error(error))
  .finally(() => console.log("Operation complete."));
```

#### `async/await` с обработкой ошибок:
```js
async function fetchData() {
  try {
    const response = await fetchData();
    console.log(response);
  } catch (error) {
    console.error(error);
  } finally {
    console.log("Operation complete.");
  }
}
fetchData();
```

## 2. Backend

### 1) Как вы обеспечиваете безопасность API от SQL-инъекций? Какие еще типы атак нужно учитывать?

- **Защита от SQL-инъекций**: Использование ORM (например, Django ORM), которое автоматически экранирует данные.
- **Другие атаки**:
  - **XSS (Cross-Site Scripting)**: Валидация и экранирование пользовательского ввода.
  - **CSRF (Cross-Site Request Forgery)**: Использование CSRF-токенов (в Django встроено).
  - **DoS (Denial of Service)**: Ограничение запросов (rate limiting) и валидация данных.

### 2) Объясните, что такое RESTful API и какие существуют методы HTTP-запросов. Как они соответствуют CRUD-операциям?

RESTful API — это архитектурный стиль для создания API, основанный на HTTP, где ресурсы доступны по URL, а операции с ними выполняются через стандартные методы HTTP.

- **GET** — получение данных (Read)
- **POST** — создание ресурса (Create)
- **PUT/PATCH** — обновление ресурса (Update)
- **DELETE** — удаление ресурса (Delete)

### 3) Чем отличаются реляционные и нереляционные базы данных? В каких случаях лучше использовать каждую из них?

- **Реляционные БД (PostgreSQL, MySQL)**: Хранят данные в таблицах с фиксированной схемой, обеспечивают целостность (ACID). **Применение**: финансы, CRM.
- **Нереляционные БД (MongoDB, Redis)**: Гибкая структура, удобны для хранения документов и больших объемов данных. **Применение**: соцсети, аналитика.

### 4) Как бы вы организовали логирование и мониторинг для серверного приложения?

- **Логирование**: Django logging, ELK-стек (Elasticsearch, Logstash, Kibana)
- **Мониторинг**: Prometheus (метрики), Grafana (визуализация)

## 3. Базы данных

### 1) Объясните разницу между индексацией и нормализацией данных. Приведите пример, когда избыточность данных может быть полезной.

- **Индексация**: Ускоряет поиск по столбцам.
- **Нормализация**: Устранение избыточности данных, разбиение таблиц.
- **Пример избыточности**: Хранение итоговой суммы заказа в `orders`, несмотря на возможность вычисления через `order_items`.

### 2) В чем различие между `JOIN` и `UNION` в SQL? Когда использовать каждый из них?

- **`JOIN`**: "Горизонтальное" объединение данных из связанных таблиц.
- **`UNION`**: "Вертикальное" объединение результатов нескольких `SELECT`-запросов.

Используйте `JOIN`, если нужно объединить данные из нескольких таблиц, и `UNION`, если нужно объединить результаты двух однотипных запросов.

